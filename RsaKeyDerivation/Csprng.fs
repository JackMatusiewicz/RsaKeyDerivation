namespace RsaKeyDerivation

open System.Security.Cryptography

type Csprng = {
    Counter : bigint
    Key : AesManaged
}

type Block = private Block of byte[]

module Csprng =
    open State
    open System
    open System.IO

    //Eventually this will need to be generated by a passphrase.
    let create () =
        let aes = new AesManaged()
        aes.Mode <- CipherMode.ECB
        aes.Padding <- PaddingMode.None
        {Counter = bigint 0; Key = aes;}

    let private createBlock (data : byte[]) : Block = Block data
    let getData (Block data) = data

    let updateCounter csprng : Csprng =
        {Key = csprng.Key; Counter = csprng.Counter + (bigint 1)}

    let generateBlock : State<Csprng, Block> =
        let encrypt (key : AesManaged) (data : byte[]) : byte[] =
            use encryptTransform = key.CreateEncryptor()
            use ms = new MemoryStream()
            use cs = new CryptoStream(ms, encryptTransform, CryptoStreamMode.Write)
            cs.Write(data, 0, data.Length)
            ms.ToArray()

        let generate (csprng : Csprng) : (Block * Csprng) =
            let bytesInGeneratedNumber = csprng.Key.BlockSize / 8
            let counterData = csprng.Counter.ToByteArray();
            let buffer = Array.create bytesInGeneratedNumber (byte 0)
            System.Array.Copy(counterData, 0, buffer, 0, counterData.Length)
            let randomNumber = encrypt (csprng.Key) buffer
            (Block randomNumber, updateCounter csprng)

        State generate


    //Merges the generate block into the random number, doesn't use the state monad to combine blocks.
    //May end up being what is needed.
    let generateRandom (numberOfBlocks : int) : State<Csprng, bigint> =
        let encrypt (key : AesManaged) (data : byte[]) : byte[] =
            use encryptTransform = key.CreateEncryptor()
            use ms = new MemoryStream()
            use cs = new CryptoStream(ms, encryptTransform, CryptoStreamMode.Write)
            cs.Write(data, 0, data.Length)
            ms.ToArray()

        let rec generateCounterData (counter : bigint) (acc : byte[] list) (count : int) (size : int) : byte[] =
            match count with
            | 0 -> (List.rev >> Array.concat) acc
            | _ ->
                let counterData = counter.ToByteArray();
                let buffer = Array.create size (byte 0)
                System.Array.Copy(counterData, 0, buffer, 0, counterData.Length)
                generateCounterData (counter + (bigint 1)) (buffer :: acc) (count - 1) size

        let ensurePositive (numberOfBitsUsed : int) (n : bigint) =
            n &&& (((bigint 1) <<< (numberOfBitsUsed - 1)) - (bigint 1))

        let generate (csprng : Csprng) : (bigint * Csprng) =
            let numberOfBitsUsed = numberOfBlocks * 16 * 8
            let bytesInGeneratedNumber = csprng.Key.BlockSize / 8
            let counterData = generateCounterData (csprng.Counter) [] numberOfBlocks bytesInGeneratedNumber
            let randomBytes = encrypt (csprng.Key) counterData
            let randomNumber = bigint randomBytes |> ensurePositive numberOfBitsUsed
            (randomNumber, {csprng with Counter = csprng.Counter + (bigint numberOfBlocks)})

        State <| generate

    //Will ensure it is always a positive value.
    let generate (numberOfBlocks : int) : State<Csprng, bigint> =
        let numberOfBitsUsed = numberOfBlocks * 16 * 8
        let blocksToArrays : Block list -> byte[] list = List.map getData
        let ensurePositive (n : bigint) = n &&& (((bigint 1) <<< (numberOfBitsUsed - 1)) - (bigint 1))
        let convertToNumber = blocksToArrays >> Array.concat >> bigint >> ensurePositive
        let getAllBlocks : State<Csprng, Block list> = replicateState numberOfBlocks generateBlock
        map convertToNumber getAllBlocks

    // min inclusive, max exclusive.
    let range (min : bigint) (max : bigint) : State<Csprng, bigint> =
        let findLargerPowerOfTwo (value : bigint) =
            let rec find (acc : bigint) =
                if acc >= value then
                    acc
                else
                    find (acc <<< 1)
            find (bigint 1)

        let range = max - min
        let bound = findLargerPowerOfTwo range
        let bytesRequired = bound.ToByteArray().Length

        let rec find () = state {
            let! number = generate bytesRequired
            let numberInRange = number % bound
            if numberInRange < range then
                return numberInRange + min
            else
                return! find ()
        }
        find ()