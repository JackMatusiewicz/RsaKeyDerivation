namespace RsaKeyDerivation

open System.Security.Cryptography

type Csprng = {
    Counter : bigint
    Key : AesManaged
}

type Block = private Block of byte[]

module Csprng =
    open State
    open System
    open System.IO

    //Eventually this will need to be generated by a passphrase.
    let create () =
        let aes = new AesManaged()
        aes.Mode <- CipherMode.ECB
        aes.Padding <- PaddingMode.None
        {Counter = bigint 0; Key = aes;}

    //Todo, move this to a Result<failure, success> rather than error.
    let private createBlock (data : byte[]) : Block = Block data
    let getData (Block data) = data

    let updateCounter csprng : Csprng =
        {Key = csprng.Key; Counter = csprng.Counter + (bigint 1)}

    let generateBlock : State<Csprng, Block> =
        let encrypt (key : AesManaged) (data : byte[]) : byte[] =
            use encryptTransform = key.CreateEncryptor()
            use ms = new MemoryStream()
            use cs = new CryptoStream(ms, encryptTransform, CryptoStreamMode.Write)
            cs.Write(data, 0, data.Length)
            ms.ToArray()

        let generate (csprng : Csprng) : (Block * Csprng) =
            let bytesInGeneratedNumber = csprng.Key.BlockSize / 8
            let counterData = csprng.Counter.ToByteArray();
            let buffer = Array.create bytesInGeneratedNumber (byte 0)
            System.Array.Copy(counterData, 0, buffer, 0, counterData.Length)
            let randomNumber = encrypt (csprng.Key) buffer
            (Block randomNumber, updateCounter csprng)

        State generate

    //Will ensure it is always a positive value.
    let generate (numberOfBlocks : int) : State<Csprng, bigint> = 
        let merge (a : byte[]) (b : byte[]) : byte[] =
            let totalSize = a.Length + b.Length
            let buffer = Array.create totalSize (byte 0)
            System.Array.Copy(a, 0, buffer, 0, a.Length)
            System.Array.Copy(b, 0, buffer, a.Length, b.Length)
            buffer
        
        let numberOfBitsUsed = numberOfBlocks * 16 * 8
        let blocksToArrays : Block list -> byte[] list = List.map getData
        let mergeBlocks : byte[] list -> byte[] = List.fold merge [||]
        let ensurePositive (n : bigint) = n &&& (((bigint 1) <<< (numberOfBitsUsed - 1)) - (bigint 1))
        let convertToNumber = blocksToArrays >> mergeBlocks >> bigint >> ensurePositive
        let getAllBlocks : State<Csprng, Block list> = replicateState numberOfBlocks generateBlock
        map convertToNumber getAllBlocks

    // min inclusive, max exclusive.
    let range (min : bigint) (max : bigint) : State<Csprng, bigint> =
        let findLargerPowerOfTwo (value : bigint) =
            let rec find (acc : bigint) =
                if acc >= value then
                    acc
                else
                    find (acc <<< 1)
            find (bigint 1)

        let range = max - min
        let bound = findLargerPowerOfTwo range
        let bytesRequired = bound.ToByteArray().Length

        let rec find () = state {
            let! number = generate bytesRequired
            let numberInRange = number % bound
            if numberInRange < range then
                return numberInRange + min
            else
                return! find ()
        }
        find ()