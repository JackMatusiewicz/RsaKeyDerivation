namespace RsaKeyDerivation

open System.Security.Cryptography
open State
open System
open System.IO
open System.Numerics

type Csprng = {
    Counter : bigint
    Key : AesManaged
}

[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]
module Csprng =

    //Eventually this will need to be generated by a passphrase.
    let create () =
        let aes = new AesManaged()
        aes.Mode <- CipherMode.ECB
        aes.Padding <- PaddingMode.None
        {Counter = bigint 0; Key = aes;}

    let updateCounter csprng : Csprng =
        {Key = csprng.Key; Counter = csprng.Counter + (bigint 1)}

    let setMsb (p : byte[]) : bigint =
        match p.Length with
        | 0 -> (bigint 0)
        | _ ->
            p.[p.Length - 1] <- (p.[p.Length - 1] &&& (byte 0xBF)) ||| ((byte 1) <<< 7)
            let updatedBytes = Array.concat [p; [|0uy|]]
            BigInteger(updatedBytes)

    ///Generates a random positive number.
    let random (numberOfBlocks : int) : State<Csprng, bigint> =
        let encrypt (key : AesManaged) (data : byte[]) : byte[] =
            use encryptTransform = key.CreateEncryptor()
            use ms = new MemoryStream()
            use cs = new CryptoStream(ms, encryptTransform, CryptoStreamMode.Write)
            cs.Write(data, 0, data.Length)
            cs.FlushFinalBlock()
            ms.ToArray()

        let rec generateCounterData (counter : bigint) (size : int) : seq<byte[]> = seq {
            let counterData = counter.ToByteArray();
            let buffer = Array.create size (byte 0)
            System.Array.Copy(counterData, 0, buffer, 0, counterData.Length)
            yield buffer
            yield! generateCounterData (counter + bigint 1) (size)
        }

        let generate (csprng : Csprng) : (bigint * Csprng) =
            let numberOfBitsUsed = numberOfBlocks * csprng.Key.BlockSize
            let bytesInBlock = csprng.Key.BlockSize / 8
            let counterData =
                bytesInBlock
                |> generateCounterData (csprng.Counter)
                |> (Seq.take numberOfBlocks >> Array.concat)
            let randomNumber =
                counterData
                |> encrypt (csprng.Key)
                |> setMsb

            (randomNumber, {csprng with Counter = csprng.Counter + (bigint numberOfBlocks)})

        State <| generate

    /// min inclusive, max exclusive.
    let range (min : bigint) (max : bigint) : State<Csprng, bigint> =
        let findLargerPowerOfTwo (value : bigint) =
            let rec find (acc : bigint) =
                if acc >= value then
                    acc
                else
                    find (acc <<< 1)
            find (bigint 1)

        let range = max - min
        let bound = findLargerPowerOfTwo range
        let bytesRequired = bound.ToByteArray().Length

        let rec find () = state {
            let! number = random bytesRequired
            let numberInRange = number % bound
            if numberInRange < range then
                return numberInRange + min
            else
                return! find ()
        }
        find ()
