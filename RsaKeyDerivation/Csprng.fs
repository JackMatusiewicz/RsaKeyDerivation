namespace RsaKeyDerivation

open System.Security.Cryptography

type Csprng = {
    Counter : bigint
    Key : AesManaged
}

type Block = private Block of byte[]

module Csprng =
    open State
    open System
    open System.IO

    //Eventually this will need to be generated by a passphrase.
    let create () =
        let aes = new AesManaged()
        aes.Mode <- CipherMode.ECB
        aes.Padding <- PaddingMode.None
        {Counter = bigint 0; Key = aes;}

    //Todo, move this to a Result<failure, success> rather than error.
    let private createBlock (data : byte[]) : Block = Block data
    let getData (Block data) = data

    let updateCounter csprng : Csprng =
        {Key = csprng.Key; Counter = csprng.Counter + (bigint 1)}

    let generateBlock : State<Csprng, Block> =
        let encrypt (key : AesManaged) (data : byte[]) : byte[] =
            use encryptTransform = key.CreateEncryptor()
            use ms = new MemoryStream()
            use cs = new CryptoStream(ms, encryptTransform, CryptoStreamMode.Write)
            cs.Write(data, 0, data.Length)
            ms.ToArray()

        let generate (csprng : Csprng) : (Block * Csprng) =
            let bytesInGeneratedNumber = csprng.Key.BlockSize / 8
            let counterData = csprng.Counter.ToByteArray();
            let buffer = Array.create bytesInGeneratedNumber (byte 0)
            System.Array.Copy(counterData, 0, buffer, 0, counterData.Length)
            let randomNumber = encrypt (csprng.Key) buffer
            (Block randomNumber, updateCounter csprng)

        State generate

    let generate (numberOfBlocks : int) : State<Csprng, bigint> = 
        let merge (a : byte[]) (b : byte[]) : byte[] =
            let totalSize = a.Length + b.Length
            let buffer = Array.create totalSize (byte 0)
            System.Array.Copy(a, 0, buffer, 0, a.Length)
            System.Array.Copy(b, 0, buffer, a.Length, b.Length)
            buffer
        
        let blocksToArrays : Block list -> byte[] list = List.map getData
        let mergeBlocks : byte[] list -> byte[] = List.fold merge [||]
        let convertToNumber = blocksToArrays >> mergeBlocks >> bigint
        let getAllBlocks : State<Csprng, Block list> = replicateState numberOfBlocks generateBlock
        map convertToNumber getAllBlocks

        


